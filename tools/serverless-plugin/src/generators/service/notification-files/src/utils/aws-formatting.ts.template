import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import { NotifyError } from '../../types/notify-error';

dayjs.extend(utc);

const LOGS_INSIGHTS_TIME_FORMAT = 'YYYY-MM-DDTHH:mm:ss.SSS[Z]';

/**
 * Extracts the name from an AWS Step Functions or Lambda execution ARN
 * It assumes that the arn is always in the correct format
 * For example:
 * - The Step Functions execution ARN format is: arn:aws:states:region:account_id:execution:state_machine_name:execution_name
 * - The Lambda execution ARN format is: arn:aws:lambda:region:account_id:function:function_name
 *
 * @param {string} arn - The AWS Step Functions execution ARN.
 * @returns {string} The extracted name from the execution ARN.
 * @throws {Error} If the provided ARN is invalid or does not contain a name.
 *
 * @example
 * const arn = 'arn:aws:states:us-east-1:123456789012:execution:my-state-machine:my-execution';
 * const name = extractNameFromExecutionArn(arn);
 * console.log(name); // Output: 'my-state-machine: my-execution'
 *
 * @example
 * const arn = 'arn:aws:lambda:us-east-1:123456789012:function:my-function';
 * const name = extractNameFromExecutionArn(arn);
 * console.log(name); // Output: 'my-function'
 */
export function extractNameFromExecutionArn(arn: string) {
    const parts = arn.split(':');
    let name = parts[6];

    if (!name) {
        throw new Error('Invalid execution ARN');
    }

    // If it's a Step Function execution ARN, we want to include execution name
    if (parts.length === 8) {
        name += `: ${parts[7]}`;
    }

    return name;
}

/**
 * Extracts the name from a resource name string.
 * It assumes our resource name is in the correct format
 * For example:
 * - Lambda resource name format is: brand-int-service-name-stage-lambdaName
 * - Step function resource name format is: brand-int-service-name-stage-stepFunctionName:994ee932-8e5f-f59f-5619-ebdefd8af815_087eb4a0-92a4-30d2-eea4-c078e9b9e5fa
 *
 * @param {string} resourceName - The resource name string.
 * @returns {string} The extracted name from the resource name.
 *
 * @example
 * const resourceName = 'brand-int-service-name-stage-lambdaName';
 * const name = extractNameFromResourceName(resourceName);
 * console.log(name); // Output: 'lambdaName'
 *
 * @example
 * const resourceName = 'brand-int-service-name-stage-stepFunctionName:994ee932-8e5f-f59f-5619-ebdefd8af815_087eb4a0-92a4-30d2-eea4-c078e9b9e5fa';
 * const name = extractNameFromResourceName(resourceName);
 * console.log(name); // Output: 'stepFunctionName'
 */
export function extractNameFromResourceName(resourceName: string) {
    // Only Step Function resource name contains : character.
    if (resourceName.includes(':')) {
        const [stateMachineName, executionName] = resourceName.split(':');

        // This is a scheduled execution, we will use the state machine name instead
        resourceName = (executionName?.includes('_') ? stateMachineName : executionName) as string;
    }

    return resourceName.split('-').pop() as string;
}

/**
 * Extracts the error details from the error detail object
 * Notes:
 *  - Lambda sends a JSON string in detail.cause
 *  - Step Function Fail step sends an object that contains both detail.cause & detail.error
 *  - When Step Function rethrow lambda error, it sends detail.cause is not a JSON string
 *
 * @param {NotifyError.InvocationEvent['detail']} detail - The detail object to extract the error details from
 * @returns {NotifyError.Cause} The error details
 *
 * @example
 * const detail = {
 *   cause: '{"errorType":"MyError","errorMessage":"Something went wrong"}',
 *   error: "MyError"
 * };
 * const errorDetails = extractErrorDetails(detail);
 * console.log(errorDetails);
 * // Output: { errorType: "MyError", errorMessage: "Something went wrong" }
 */
export function extractErrorDetails(
    detail: NotifyError.InvocationEvent['detail']
): NotifyError.Cause {
    const { cause, error } = detail;

    let errorType = error || 'UnknownError';
    let errorMessage = cause || 'Unknown Error';

    try {
        // There are some cases when StepFunction re-throw Lambda errors.
        // In these cases, the cause will not be a json string
        const causeObj = JSON.parse(cause || '{}') as NotifyError.Cause;
        errorType = causeObj.errorType || errorType;
        errorMessage = causeObj.errorMessage || errorMessage;
    } catch (error) {
        console.warn('Error parsing cause, using as literal string: ', {
            error,
        });
    }

    return {
        errorType,
        errorMessage,
    };
}

/**
 * Generates a CloudWatch Logs Insights URL for a specific log group and request ID.
 * The URL includes a query to filter logs by the provided request ID and a time range
 * of 10 minutes before and after the current time.
 *
 * @param {string} region - The AWS region where the log group is located.
 * @param {string} logGroupName - The name of the CloudWatch log group.
 * @param {string} requestId - The request ID to filter logs by.
 * @param {Date} [currentTime=new Date()] - The current time to calculate the time range for the query.
 * @returns {string} The generated CloudWatch Logs Insights URL.
 *
 * @example
 * const region = 'us-east-1';
 * const logGroupName = '/aws/lambda/my-function';
 * const requestId = '12345678-1234-1234-1234-123456789012';
 * const url = generateCloudWatchInsightUrl(region, logGroupName, requestId);
 * console.log(url);
 */
function generateCloudWatchInsightUrl(
    region: string,
    logGroupName: string,
    requestId: string,
    currentTime: Date = new Date()
): string {
    const logInsightUrl = `https://${region}.console.aws.amazon.com/cloudwatch/home?region=${region}#logsV2:logs-insights`;

    const encodedLogGroupName = encodeURIComponent(encodeURIComponent(logGroupName)).replace(
        /%/g,
        '$'
    );

    const end = `end~'${dayjs
        .utc(currentTime)
        .add(10, 'minutes')
        .format(LOGS_INSIGHTS_TIME_FORMAT)}`;

    const start = `start~'${dayjs
        .utc(currentTime)
        .subtract(10, 'minutes')
        .format(LOGS_INSIGHTS_TIME_FORMAT)}`;

    const query = encodeURIComponent(
        `fields @timestamp, @message, @logStream | filter @requestId = "${requestId}" | sort @timestamp asc`
    ).replace(/%/g, '*');

    const queryDetail = `~(${end}~${start}~timeType~'ABSOLUTE~tz~'UTC~editorString~'${query}~queryId~'~source~(~'${encodedLogGroupName})~lang~'CWLI)`;

    return `${logInsightUrl}?queryDetail=${queryDetail}`;
}

/**
 * Generates a Step Functions execution URL for a specific execution ARN.
 * The URL links to the AWS Management Console for viewing the execution details.
 *
 * @param {string} region - The AWS region where the Step Function is located.
 * @param {string} executionArn - The Step Function execution ARN.
 * @returns {string} The generated Step Functions execution URL.
 *
 * @example
 * const region = 'us-east-1';
 * const executionArn = 'arn:aws:states:us-east-1:123456789012:execution:my-state-machine:my-execution';
 * const url = generateStepFunctionUrl(region, executionArn);
 * console.log(url);
 */
function generateStepFunctionUrl(region: string, executionArn: string): string {
    return `https://${region}.console.aws.amazon.com/states/home?region=${region}#/v2/executions/details/${executionArn}`;
}

/**
 * Generates a list of AWS Chatbot custom additional steps.
 * These steps can be used in custom message `nextStep` or merge with the description.
 * Note:
 * * Description is limited to 8000 characters
 * * Each individual nextStep is limited to 350 characters
 * * For more information, please check https://docs.aws.amazon.com/chatbot/latest/adminguide/custom-notifs.html
 *
 * @param {NotifyError.NextStepsInput} input - The input object containing the source, region, executionArn, and logGroupName.
 * @returns {string[]} An array of strings representing the next steps.
 * @throws {Error} If the required parameters are missing for the specified source.
 */
export function generateAdditionalSteps(input: NotifyError.NextStepsInput) {
    const { source, region, executionArn, logGroupName, requestId } = input;
    const steps: string[] = [];

    if (source === 'aws.lambda') {
        steps.push(
            `Check the <${generateCloudWatchInsightUrl(
                region,
                logGroupName as string,
                requestId as string
            )}|*CloudWatch Insight*> for more details.`
        );
    }

    if (source === 'aws.states') {
        steps.push(
            `Check the <${generateStepFunctionUrl(
                region,
                executionArn
            )}|*Step Functions execution*> for more details.`
        );
    }

    return steps;
}
